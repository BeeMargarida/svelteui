import{S as V,i as K,s as U,D as P,w as X,a4 as Y,y as C,a as Z,z as L,c as w,A as I,b as B,J as O,a6 as Q,a5 as x,g as m,d as g,B as W,h as E,M as F,ai as $,Q as ee,e as G,v as oe,f as le,C as te,G as re,H as se,I as ae,q as ne,r as ie,u as fe}from"./index.b4f0bbdc.js";import{f as be,E as ue,B as me}from"./Box.195443f6.js";import{T as ce}from"./Text.d4cabcdc.js";const z={xs:1,sm:2,md:3,lg:4,xl:5},_e=be((l,{color:o,size:e,variant:t})=>{const{size:s,themeColor:a}=l.fn;return{root:{},horizontal:{border:0,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderTopColor:a(o,4),borderTopStyle:t,margin:"12px 0px 12px 0px"},vertical:{border:0,alignSelf:"stretch",height:"100%",borderLeftWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderLeftColor:a(o,4),borderLeftStyle:t},showsLabel:{borderTop:"0 !important"},label:{display:"flex",alignItems:"center",color:o==="dark"?a("dark",1):a(o,6),[`${l.dark} &`]:{color:o==="dark"?a("dark",1):a(o,5)},"&.left":{"&::before":{display:"none"}},"&.right":{"&::after":{display:"none"}},"&::before":{content:'""',flex:1,height:1,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderTopStyle:`${t}`,borderTopColor:a(o,4),marginRight:"10px",[`${l.dark} &`]:{borderTopColor:a(o,3)}},"&::after":{content:'""',flex:1,borderTopWidth:typeof e=="number"?`${e}px`:s({size:e,sizes:z}),borderTopStyle:`${t}`,borderTopColor:a(o,3),marginLeft:"10px"}}}}),ge=Object.freeze([{error:!0,message:"If using label or label slot, it cannot use orientation 'vertical'",solution:`
                If your component looks like this:
                
                &lt;Divider orientation='vertical' label='text...'&lt;/Divider&gt;
                                        ^^^^^^^^^ - Try changing orientation to 'horizontal'
                `}]),de=l=>({}),J=l=>({});function M(l){var a;let o,e;const t=[{class:l[12](l[11].label,l[6])},l[7],{size:((a=l[7])==null?void 0:a.size)||l[4]}];let s={$$slots:{default:[he]},$$scope:{ctx:l}};for(let n=0;n<t.length;n+=1)s=P(s,t[n]);return o=new ce({props:s}),{c(){C(o.$$.fragment)},l(n){L(o.$$.fragment,n)},m(n,b){I(o,n,b),e=!0},p(n,b){var r;const u=b&6352?O(t,[b&6208&&{class:n[12](n[11].label,n[6])},b&128&&Q(n[7]),b&144&&{size:((r=n[7])==null?void 0:r.size)||n[4]}]):{};b&4194336&&(u.$$scope={dirty:b,ctx:n}),o.$set(u)},i(n){e||(m(o.$$.fragment,n),e=!0)},o(n){g(o.$$.fragment,n),e=!1},d(n){W(o,n)}}}function pe(l){let o;return{c(){o=ne(l[5])},l(e){o=ie(e,l[5])},m(e,t){B(e,o,t)},p(e,t){t&32&&fe(o,e[5])},d(e){e&&E(o)}}}function he(l){let o;const e=l[20].label,t=te(e,l,l[22],J),s=t||pe(l);return{c(){s&&s.c()},l(a){s&&s.l(a)},m(a,n){s&&s.m(a,n),o=!0},p(a,n){t?t.p&&(!o||n&4194304)&&re(t,e,a,a[22],o?ae(e,a[22],n,de):se(a[22]),J):s&&s.p&&(!o||n&32)&&s.p(a,o?n:-1)},i(a){o||(m(s,a),o=!0)},o(a){g(s,a),o=!1},d(a){s&&s.d(a)}}}function ke(l){let o,e,t=l[15]&&M(l);return{c(){t&&t.c(),o=G()},l(s){t&&t.l(s),o=G()},m(s,a){t&&t.m(s,a),B(s,o,a),e=!0},p(s,a){s[15]?t?(t.p(s,a),a&32768&&m(t,1)):(t=M(s),t.c(),m(t,1),t.m(o.parentNode,o)):t&&(oe(),g(t,1,1,()=>{t=null}),le())},i(s){e||(m(t),e=!0)},o(s){g(t),e=!1},d(s){t&&t.d(s),s&&E(o)}}}function Te(l){let o,e,t,s,a;o=new ue({props:{observable:l[8],component:"Divider",code:l[9]}});const n=[{use:l[2]},{class:l[12](l[3],l[11].root,l[14]?l[11].horizontal:{},l[13]?l[11].vertical:{},l[15]?l[11].showsLabel:{},l[10]({css:l[1]}))},l[16]];function b(r){l[21](r)}let u={$$slots:{default:[ke]},$$scope:{ctx:l}};for(let r=0;r<n.length;r+=1)u=P(u,n[r]);return l[0]!==void 0&&(u.element=l[0]),t=new me({props:u}),X.push(()=>Y(t,"element",b)),{c(){C(o.$$.fragment),e=Z(),C(t.$$.fragment)},l(r){L(o.$$.fragment,r),e=w(r),L(t.$$.fragment,r)},m(r,f){I(o,r,f),B(r,e,f),I(t,r,f),a=!0},p(r,[f]){const c={};f&256&&(c.observable=r[8]),f&512&&(c.code=r[9]),o.$set(c);const _=f&130062?O(n,[f&4&&{use:r[2]},f&64522&&{class:r[12](r[3],r[11].root,r[14]?r[11].horizontal:{},r[13]?r[11].vertical:{},r[15]?r[11].showsLabel:{},r[10]({css:r[1]}))},f&65536&&Q(r[16])]):{};f&4233456&&(_.$$scope={dirty:f,ctx:r}),!s&&f&1&&(s=!0,_.element=r[0],x(()=>s=!1)),t.$set(_)},i(r){a||(m(o.$$.fragment,r),m(t.$$.fragment,r),a=!0)},o(r){g(o.$$.fragment,r),g(t.$$.fragment,r),a=!1},d(r){W(o,r),r&&E(e),W(t,r)}}}function ye(l,o,e){let t,s,a,n,b,u;const r=["use","element","class","override","color","orientation","size","label","labelPosition","labelProps","variant"];let f=F(o,r),{$$slots:c={},$$scope:_}=o;const j=$(c);let{use:q=[],element:T=void 0,class:v="",override:S={},color:d="gray",orientation:p="horizontal",size:h="xs",label:y=null,labelPosition:H="left",labelProps:N=null,variant:k="solid"}=o,D=!1,A;s&&(y||j.label)&&(D=!0,A=ge[0]);function R(i){T=i,e(0,T)}return l.$$set=i=>{o=P(P({},o),ee(i)),e(16,f=F(o,r)),"use"in i&&e(2,q=i.use),"element"in i&&e(0,T=i.element),"class"in i&&e(3,v=i.class),"override"in i&&e(1,S=i.override),"color"in i&&e(17,d=i.color),"orientation"in i&&e(18,p=i.orientation),"size"in i&&e(4,h=i.size),"label"in i&&e(5,y=i.label),"labelPosition"in i&&e(6,H=i.labelPosition),"labelProps"in i&&e(7,N=i.labelProps),"variant"in i&&e(19,k=i.variant),"$$scope"in i&&e(22,_=i.$$scope)},l.$$.update=()=>{l.$$.dirty&262176&&e(15,t=(y||j.label)&&p==="horizontal"),l.$$.dirty&262144&&e(13,s=p==="vertical"),l.$$.dirty&262144&&e(14,a=p==="horizontal"),l.$$.dirty&256&&D&&e(1,S={display:"none"}),l.$$.dirty&655376&&e(12,{cx:n,classes:b,getStyles:u}=_e({color:d,size:h,variant:k},{name:"Divider"}),n,(e(11,b),e(17,d),e(4,h),e(19,k)),(e(10,u),e(17,d),e(4,h),e(19,k)))},[T,S,q,v,h,y,H,N,D,A,u,b,n,s,a,t,f,d,p,k,c,R,_]}class ze extends V{constructor(o){super(),K(this,o,ye,Te,U,{use:2,element:0,class:3,override:1,color:17,orientation:18,size:4,label:5,labelPosition:6,labelProps:7,variant:19})}}const Ce=ze;export{Ce as D};
